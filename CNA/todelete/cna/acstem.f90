module acstem
    USE ACSTEM_PARAMETERS, ONLY: NUM_IMAGE_ROWS, NUM_IMAGE_COLS
    implicit none
    REAL(KIND=8), DIMENSION(NUM_IMAGE_ROWS, NUM_IMAGE_COLS), SAVE :: EXPERIMENTAL_IMAGE
    REAL(KIND=8), DIMENSION(NUM_IMAGE_ROWS, NUM_IMAGE_COLS), SAVE :: SIMULATED_IMAGE

contains
    SUBROUTINE ACSTEM_OBJ_FUNC(NATOMS, COORDS, SIG, ZPOW, MSE, GRAD, GTEST, HTEST)
        USE acstem_parameters, ONLY: ATOMIC_NUM, NUM_IMAGE_ROWS, LOWERBOUND, UPPERBOUND,&
            NUM_IMAGE_COLS, EXPERIMENTAL_IMAGE_FILE
        IMPLICIT NONE
        INTEGER, INTENT(IN) :: NATOMS
        REAL(KIND=8), DIMENSION(3*NATOMS), INTENT(IN) :: COORDS
        REAL(KIND=8), DIMENSION(3*NATOMS), INTENT(OUT):: GRAD
        REAL(KIND=8), INTENT(IN)  :: SIG, ZPOW
        REAL(KIND=8), INTENT(OUT) :: MSE
        LOGICAL, INTENT(IN) :: GTEST, HTEST
        INTEGER :: I, J
        LOGICAL :: INIT=.TRUE.
        REAL(KIND=8), DIMENSION(2), PARAMETER :: XBOUND=(/LOWERBOUND(1), UPPERBOUND(1)/)
        REAL(KIND=8), DIMENSION(2), PARAMETER :: YBOUND=(/LOWERBOUND(2), UPPERBOUND(2)/)
        IF(INIT) THEN
            INIT=.FALSE.
            CALL GET_EXPERIMENTAL_IMAGE(NUM_IMAGE_ROWS, NUM_IMAGE_COLS, EXPERIMENTAL_IMAGE_FILE)
        ENDIF
        CALL GET_SIMULATED_IMAGE(NATOMS, ATOMIC_NUM, NUM_IMAGE_ROWS, NUM_IMAGE_COLS,&
             COORDS, SIG, ZPOW, XBOUND, YBOUND)
        MSE = SUM((EXPERIMENTAL_IMAGE - SIMULATED_IMAGE)**2)/DBLE(NUM_IMAGE_ROWS*NUM_IMAGE_COLS)
    END SUBROUTINE ACSTEM_OBJ_FUNC

    SUBROUTINE GET_SIMULATED_IMAGE(NATOMS, ATOMIC_NUM, NROWS, NCOLS, COORDS, &
        SIGMA, BETA, XBOUND, YBOUND)
        IMPLICIT NONE
        INTEGER, INTENT(IN) :: NATOMS, NROWS, NCOLS, ATOMIC_NUM
        REAL(KIND=8), INTENT(IN) :: SIGMA, BETA
        REAL(KIND=8), INTENT(IN), DIMENSION(3*NATOMS) :: COORDS
        REAL(KIND=8), INTENT(IN), DIMENSION(2) :: XBOUND
        REAL(KIND=8), INTENT(IN), DIMENSION(2) :: YBOUND
        REAL(KIND=8) :: XI, YJ, DX, DY, IMIJ, HEIGHT, ALPHA, XSTEP, YSTEP, TMPCNST
        REAL(KIND=8), DIMENSION(NROWS) :: X_AXIS
        REAL(KIND=8), DIMENSION(NCOLS) :: Y_AXIS
        INTEGER :: I, J, K
        LOGICAL, SAVE :: INIT = .TRUE.
        IF(INIT) THEN
            XSTEP = (XBOUND(2) - XBOUND(1))/DBLE(NROWS)
            YSTEP = (YBOUND(2) - YBOUND(1))/DBLE(NCOLS)
            X_AXIS = XBOUND(1) + XSTEP*(/(DBLE(I),I=1, NROWS)/)
            Y_AXIS = YBOUND(1) + YSTEP*(/(DBLE(I),I=1, NCOLS)/)
            INIT=.FALSE.
        ENDIF
        HEIGHT = (DBLE(ATOMIC_NUM))**beta
        ALPHA = 1.0D0/(2.0D0*sigma*sigma)
        DO J=1, NCOLS
            DO I=1, NROWS
                IMIJ = 0.0D0
                DO K=1, NATOMS
                    DX = X_AXIS(I) - COORDS(3*K - 2)
                    DY = Y_AXIS(J) - COORDS(3*K - 1)
                    IMIJ = IMIJ + HEIGHT*EXP(-ALPHA*(DX*DX + DY*DY))
                ENDDO
                SIMULATED_IMAGE(I, J) = IMIJ
            ENDDO
        ENDDO
    END SUBROUTINE GET_SIMULATED_IMAGE

!    SUBROUTINE GET_GRADIENT()
!        IMPLICIT NONE
!        INTEGER, INTENT(IN) :: NATOMS, NROWS, NCOLS, ATOMIC_NUM
!        REAL(KIND=8), INTENT(IN) :: SIGMA, BETA
!        REAL(KIND=8), INTENT(IN), DIMENSION(3*NATOMS) :: COORDS
!        REAL(KIND=8), INTENT(IN), DIMENSION(2) :: XBOUND
!        REAL(KIND=8), INTENT(IN), DIMENSION(2) :: YBOUND
!        REAL(KIND=8), DIMENSION(NATOMS) :: IMIJ
!        REAL(KIND=8) :: XI, YJ, DX, DY, HEIGHT, ALPHA, XSTEP, YSTEP
!        REAL(KIND=8), DIMENSION(NROWS) :: X_AXIS
!        REAL(KIND=8), DIMENSION(NCOLS) :: Y_AXIS
!        INTEGER :: I, J, K
!        LOGICAL, SAVE :: INIT = .TRUE.
!        IF(INIT) THEN
!            XSTEP = (XBOUND(2) - XBOUND(1))/DBLE(NROWS)
!            YSTEP = (YBOUND(2) - YBOUND(1))/DBLE(NCOLS)
!            X_AXIS = XBOUND(1) + XSTEP*(/(DBLE(I),I=1, NROWS)/)
!            Y_AXIS = YBOUND(1) + YSTEP*(/(DBLE(I),I=1, NCOLS)/)
!            INIT=.FALSE.
!        ENDIF
!        HEIGHT = (DBLE(ATOMIC_NUM))**BETA
!        ALPHA = 1.0D0/(2.0D0*SIGMA*SIGMA)
!        IMIJ = 0.0D0
!        DO J=1, NCOLS
!            DO I=1, NROWS
!                DO K=1, NATOMS
!                    DX = X_AXIS(I) - COORDS(3*K - 2)
!                    DY = Y_AXIS(J) - COORDS(3*K - 1)
!                    IMIJ(K) = IMIJ(K) + HEIGHT*EXP(-ALPHA*(DX*DX + DY*DY))
!                ENDDO
!                SIMULATED_IMAGE(I, J) = SUM(IMIJ)
!                SQUARED_ERROR(I,J) = EXPERIMENTAL_IMAGE(I,J) - SIMULATED_IMAGE(I,J)
!                TMPCNST = -4.0D0*ALPHA*SUM(SQUARED_ERROR(I,J))
!                ! CALCULATE GRADIENT
!                GRAD(
!            ENDDO
!        ENDDO
!    END SUBROUTINE GET_GRADIENT

    SUBROUTINE GET_EXPERIMENTAL_IMAGE(NROWS, NCOLS, IMFILE)
        IMPLICIT NONE
        INTEGER, INTENT(IN) :: NROWS, NCOLS
        CHARACTER(LEN=*), INTENT(IN) :: IMFILE
        REAL(KIND=8), DIMENSION(NCOLS) :: TMP
        INTEGER :: I, MYUNIT
        OPEN(NEWUNIT=MYUNIT, FILE=ADJUSTL(TRIM(IMFILE)), ACTION="READ", STATUS="OLD")
        DO I=1, NROWS
            READ(MYUNIT, *) EXPERIMENTAL_IMAGE(I, :)
        ENDDO
    END SUBROUTINE GET_EXPERIMENTAL_IMAGE

end module acstem
